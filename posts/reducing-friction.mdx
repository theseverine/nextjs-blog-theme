---
title: "Reducing Friction: (Mostly) Good"
description: "Reducing friction helps us, but also creates perverse incentives"
date: Aug 17 2024
---

We all love to imagine how the developer experience would be improved by reducing friction. We'd be able to get what we wanted done faster, cheaper and better, right?
But as with anything else positive, it's never a bad idea to consider the potential negative side effects of this positive change.

My personal favourite example of reducing friction generating perverse incentives comes at a fairly low level: table tests.
We've all seen this type of test: instead of writing out the code for each test, we write a generic test function and send a series of values from an array or iterable object to it.

```
test('midi.isMidiPitch()', () => {
    const table: [ string, number, boolean ][] = [
        [ 'negative numbers should fail', -1, false ],
        [ 'positive numbers should succeed', 1, true ],
        [ 'non-integers should fail', 0.5, false ],
        [ '127 should succeed', 127, true ],
        [ '128 should fail', 128, false ],
        [ '0 should succeed', 0, true ],
    ];

    test.each(table)((_, num, ret) => expect(midi.isMidiPitch(num)).toBe(ret));
});
```

Table tests make it much easier to quickly write many tests to cover your code, right?
Well, yes, they do... but the goal should be minimizing important cases not covered, not writing many tests. (If your goal is "write many tests", you've got bigger organizational problems to deal with.) 

A common case, and one I've seen many times in production: the code under test suddenly becomes more complex because of new requirements, but because it feels quicker to add three table tests than one non-table test, when a workflow you need to test isn't fully supported by the table tests you may be tempted to use the existing table tests to hack together a sort of solution (it's quicker, and it works almost as well... and I'm not falling into the sunk cost fallacy here, right? Right?).

Mitigations include: thorough code review.

Another case, which I've also seen many times in my own code: table tests make it much easier to add new tests of nebulous value whose primary effect on your project is to slightly increase the time it takes to run the test suite.
These new tests make one feel good, because they feel like further validation that the software works as expected, but how do we know if they are adding any value?
And do we actually know _why_ they're there, or did we just add them because it was easy to do quickly while already working on this part of the code?

Mitigations include: writing a brief message associated with each test in a table, explaining not _what_ is being tested but _why_ it is being tested, can help you understand whether the test should be there at all.
(These messages will also make it easier for a new team member to understand what the code under test is doing, and why we're testing it as we do.)

```
test('midi.isMidiPitch()', () => {
    const table: [ string, number, boolean ][] = [
        [ 'MIDI pitches must be integers', 0.5, false ],
        [ 'MIDI pitches may not be negative', -1, false ],
        [ 'Allow minimum MIDI pitch of 0', 0, true ],
        [ 'Allow maximum MIDI pitch of 127', 127, true ],
        [ 'MIDI pitches may not exceed the maximum', 128, false ],
    ];

    test.each(table)((_, num, ret) => expect(midi.isMidiPitch(num)).toBe(ret));
});
```

Obviously, perverse incentives don't make table tests&mdash;and other timesaving devices&mdash;bad (I certainly use table tests often), but be aware of these incentives, and their interactions with how you and your team think, and consider some simple mitigations for them.
